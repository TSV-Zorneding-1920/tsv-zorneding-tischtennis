diff --git a/node_modules/netlify-cms-backend-github/src/API.js b/node_modules/netlify-cms-backend-github/src/API.js
index 1457663..5a21377 100644
--- a/node_modules/netlify-cms-backend-github/src/API.js
+++ b/node_modules/netlify-cms-backend-github/src/API.js
@@ -1,7 +1,17 @@
-import { Base64 } from 'js-base64';
-import semaphore from 'semaphore';
-import { find, flow, get, hasIn, initial, last, partial, result, uniq } from 'lodash';
-import { map } from 'lodash/fp';
+import { Base64 } from "js-base64";
+import semaphore from "semaphore";
+import {
+  find,
+  flow,
+  get,
+  hasIn,
+  initial,
+  last,
+  partial,
+  result,
+  uniq
+} from "lodash";
+import { map } from "lodash/fp";
 import {
   getAllResponses,
   APIError,
@@ -9,34 +19,35 @@ import {
   filterPromisesWith,
   localForage,
   onlySuccessfulPromises,
-  resolvePromiseProperties,
-} from 'netlify-cms-lib-util';
+  resolvePromiseProperties
+} from "netlify-cms-lib-util";
 
-const CMS_BRANCH_PREFIX = 'cms';
+const CMS_BRANCH_PREFIX = "cms";
 
-const replace404WithEmptyArray = err => (err && err.status === 404 ? [] : Promise.reject(err));
+const replace404WithEmptyArray = err =>
+  err && err.status === 404 ? [] : Promise.reject(err);
 
 export default class API {
   constructor(config) {
-    this.api_root = config.api_root || 'https://api.github.com';
+    this.api_root = config.api_root || "https://api.github.com";
     this.token = config.token || false;
-    this.branch = config.branch || 'master';
+    this.branch = config.branch || "master";
     this.useOpenAuthoring = config.useOpenAuthoring;
-    this.repo = config.repo || '';
+    this.repo = config.repo || "";
     this.originRepo = config.originRepo || this.repo;
-    this.repoURL = `/repos/${this.repo}`;
+    this.repoURL = this.repo ? `/repos/${this.repo}` : "";
     // when not in 'useOpenAuthoring' mode originRepoURL === repoURL
-    this.originRepoURL = `/repos/${this.originRepo}`;
-    this.merge_method = config.squash_merges ? 'squash' : 'merge';
+    this.originRepoURL = this.originRepo ? `/repos/${this.originRepo}` : "";
+    this.merge_method = config.squash_merges ? "squash" : "merge";
     this.initialWorkflowStatus = config.initialWorkflowStatus;
   }
 
-  static DEFAULT_COMMIT_MESSAGE = 'Automatically generated by Netlify CMS';
-  static DEFAULT_PR_BODY = 'Automatically generated by Netlify CMS';
+  static DEFAULT_COMMIT_MESSAGE = "Automatically generated by Netlify CMS";
+  static DEFAULT_PR_BODY = "Automatically generated by Netlify CMS";
 
   user() {
     if (!this._userPromise) {
-      this._userPromise = this.request('/user');
+      this._userPromise = this.request("/user");
     }
     return this._userPromise;
   }
@@ -45,15 +56,15 @@ export default class API {
     return this.request(this.repoURL)
       .then(repo => repo.permissions.push)
       .catch(error => {
-        console.error('Problem fetching repo data from GitHub');
+        console.error("Problem fetching repo data from GitHub");
         throw error;
       });
   }
 
   requestHeaders(headers = {}) {
     const baseHeader = {
-      'Content-Type': 'application/json',
-      ...headers,
+      "Content-Type": "application/json",
+      ...headers
     };
 
     if (this.token) {
@@ -83,13 +94,13 @@ export default class API {
       }
     }
     if (params.length) {
-      path += `?${params.join('&')}`;
+      path += `?${params.join("&")}`;
     }
     return this.api_root + path;
   }
 
   parseResponse(response) {
-    const contentType = response.headers.get('Content-Type');
+    const contentType = response.headers.get("Content-Type");
     if (contentType && contentType.match(/json/)) {
       return this.parseJsonResponse(response);
     }
@@ -102,7 +113,11 @@ export default class API {
     return textPromise;
   }
 
-  request(path, options = {}, parseResponse = response => this.parseResponse(response)) {
+  request(
+    path,
+    options = {},
+    parseResponse = response => this.parseResponse(response)
+  ) {
     const headers = this.requestHeaders(options.headers || {});
     const url = this.urlFor(path, options);
     let responseStatus;
@@ -112,15 +127,20 @@ export default class API {
         return parseResponse(response);
       })
       .catch(error => {
-        throw new APIError(error.message, responseStatus, 'GitHub');
+        throw new APIError(error.message, responseStatus, "GitHub");
       });
   }
 
   async requestAllPages(url, options = {}) {
     const headers = this.requestHeaders(options.headers || {});
     const processedURL = this.urlFor(url, options);
-    const allResponses = await getAllResponses(processedURL, { ...options, headers });
-    const pages = await Promise.all(allResponses.map(res => this.parseResponse(res)));
+    const allResponses = await getAllResponses(processedURL, {
+      ...options,
+      headers
+    });
+    const pages = await Promise.all(
+      allResponses.map(res => this.parseResponse(res))
+    );
     return [].concat(...pages);
   }
 
@@ -139,7 +159,7 @@ export default class API {
   }
 
   branchNameFromRef(ref) {
-    return ref.substring('refs/heads/'.length);
+    return ref.substring("refs/heads/".length);
   }
 
   contentKeyFromRef(ref) {
@@ -147,28 +167,40 @@ export default class API {
   }
 
   checkMetadataRef() {
-    return this.request(`${this.repoURL}/git/refs/meta/_netlify_cms?${Date.now()}`, {
-      cache: 'no-store',
-    })
+    return this.request(
+      `${this.repoURL}/git/refs/meta/_netlify_cms?${Date.now()}`,
+      {
+        cache: "no-store"
+      }
+    )
       .then(response => response.object)
       .catch(() => {
         // Meta ref doesn't exist
         const readme = {
           raw:
-            '# Netlify CMS\n\nThis tree is used by the Netlify CMS to store metadata information for specific files and branches.',
+            "# Netlify CMS\n\nThis tree is used by the Netlify CMS to store metadata information for specific files and branches."
         };
 
         return this.uploadBlob(readme)
           .then(item =>
             this.request(`${this.repoURL}/git/trees`, {
-              method: 'POST',
+              method: "POST",
               body: JSON.stringify({
-                tree: [{ path: 'README.md', mode: '100644', type: 'blob', sha: item.sha }],
-              }),
-            }),
+                tree: [
+                  {
+                    path: "README.md",
+                    mode: "100644",
+                    type: "blob",
+                    sha: item.sha
+                  }
+                ]
+              })
+            })
+          )
+          .then(tree => this.commit("First Commit", tree))
+          .then(response =>
+            this.createRef("meta", "_netlify_cms", response.sha)
           )
-          .then(tree => this.commit('First Commit', tree))
-          .then(response => this.createRef('meta', '_netlify_cms', response.sha))
           .then(response => response.object);
       });
   }
@@ -188,23 +220,30 @@ export default class API {
             [`${key}.json`]: {
               path: `${key}.json`,
               raw: JSON.stringify(data),
-              file: true,
-            },
+              file: true
+            }
           };
           await this.uploadBlob(fileTree[`${key}.json`]);
-          const changeTree = await this.updateTree(branchData.sha, '/', fileTree);
-          const { sha } = await this.commit(`Updating “${key}” metadata`, changeTree);
-          await this.patchRef('meta', '_netlify_cms', sha);
+          const changeTree = await this.updateTree(
+            branchData.sha,
+            "/",
+            fileTree
+          );
+          const { sha } = await this.commit(
+            `Updating “${key}” metadata`,
+            changeTree
+          );
+          await this.patchRef("meta", "_netlify_cms", sha);
           localForage.setItem(`gh.meta.${key}`, {
             expires: Date.now() + 300000, // In 5 minutes
-            data,
+            data
           });
           this._metadataSemaphore.leave();
           resolve();
         } catch (err) {
           reject(err);
         }
-      }),
+      })
     );
   }
 
@@ -215,35 +254,41 @@ export default class API {
         return cached.data;
       }
       console.log(
-        '%c Checking for MetaData files',
-        'line-height: 30px;text-align: center;font-weight: bold',
+        "%c Checking for MetaData files",
+        "line-height: 30px;text-align: center;font-weight: bold"
       );
 
       const metadataRequestOptions = {
-        params: { ref: 'refs/meta/_netlify_cms' },
-        headers: { Accept: 'application/vnd.github.VERSION.raw' },
-        cache: 'no-store',
+        params: { ref: "refs/meta/_netlify_cms" },
+        headers: { Accept: "application/vnd.github.VERSION.raw" },
+        cache: "no-store"
       };
 
       const errorHandler = err => {
-        if (err.message === 'Not Found') {
+        if (err.message === "Not Found") {
           console.log(
-            '%c %s does not have metadata',
-            'line-height: 30px;text-align: center;font-weight: bold',
-            key,
+            "%c %s does not have metadata",
+            "line-height: 30px;text-align: center;font-weight: bold",
+            key
           );
         }
         throw err;
       };
 
       if (!this.useOpenAuthoring) {
-        return this.request(`${this.repoURL}/contents/${key}.json`, metadataRequestOptions)
+        return this.request(
+          `${this.repoURL}/contents/${key}.json`,
+          metadataRequestOptions
+        )
           .then(response => JSON.parse(response))
           .catch(errorHandler);
       }
 
-      const [user, repo] = key.split('/');
-      return this.request(`/repos/${user}/${repo}/contents/${key}.json`, metadataRequestOptions)
+      const [user, repo] = key.split("/");
+      return this.request(
+        `/repos/${user}/${repo}/contents/${key}.json`,
+        metadataRequestOptions
+      )
         .then(response => JSON.parse(response))
         .catch(errorHandler);
     });
@@ -251,15 +296,18 @@ export default class API {
 
   retrieveContent(path, branch, repoURL) {
     return this.request(`${repoURL}/contents/${path}`, {
-      headers: { Accept: 'application/vnd.github.VERSION.raw' },
+      headers: { Accept: "application/vnd.github.VERSION.raw" },
       params: { ref: branch },
-      cache: 'no-store',
+      cache: "no-store"
     }).catch(error => {
-      if (hasIn(error, 'message.errors') && find(error.message.errors, { code: 'too_large' })) {
+      if (
+        hasIn(error, "message.errors") &&
+        find(error.message.errors, { code: "too_large" })
+      ) {
         const dir = path
-          .split('/')
+          .split("/")
           .slice(0, -1)
-          .join('/');
+          .join("/");
         return this.listFiles(dir, { repoURL, branch })
           .then(files => files.find(file => file.path === path))
           .then(file => this.getBlob(file.sha, { repoURL }));
@@ -280,9 +328,9 @@ export default class API {
     return this.request(
       `${repoURL}/git/blobs/${sha}`,
       {
-        headers: { Accept: 'application/vnd.github.VERSION.raw' },
+        headers: { Accept: "application/vnd.github.VERSION.raw" }
       },
-      response => response,
+      response => response
     );
   }
 
@@ -314,52 +362,60 @@ export default class API {
   }
 
   listFiles(path, { repoURL = this.repoURL, branch = this.branch } = {}) {
-    return this.request(`${repoURL}/contents/${path.replace(/\/$/, '')}`, {
-      params: { ref: branch },
+    return this.request(`${repoURL}/contents/${path.replace(/\/$/, "")}`, {
+      params: { ref: branch }
     })
       .then(files => {
         if (!Array.isArray(files)) {
-          throw new Error(`Cannot list files, path ${path} is not a directory but a ${files.type}`);
+          throw new Error(
+            `Cannot list files, path ${path} is not a directory but a ${files.type}`
+          );
         }
         return files;
       })
-      .then(files => files.filter(file => file.type === 'file'));
+      .then(files => files.filter(file => file.type === "file"));
   }
 
   readUnpublishedBranchFile(contentKey) {
     const metaDataPromise = this.retrieveMetadata(contentKey).then(data =>
-      data.objects.entry.path ? data : Promise.reject(null),
+      data.objects.entry.path ? data : Promise.reject(null)
     );
     const repoURL = this.useOpenAuthoring
       ? `/repos/${contentKey
-          .split('/')
+          .split("/")
           .slice(0, 2)
-          .join('/')}`
+          .join("/")}`
       : this.repoURL;
     return resolvePromiseProperties({
       metaData: metaDataPromise,
       fileData: metaDataPromise.then(data =>
         this.readFile(data.objects.entry.path, null, {
           branch: data.branch,
-          repoURL,
-        }),
+          repoURL
+        })
       ),
       isModification: metaDataPromise.then(data =>
-        this.isUnpublishedEntryModification(data.objects.entry.path, this.branch),
-      ),
+        this.isUnpublishedEntryModification(
+          data.objects.entry.path,
+          this.branch
+        )
+      )
     }).catch(() => {
-      throw new EditorialWorkflowError('content is not under editorial workflow', true);
+      throw new EditorialWorkflowError(
+        "content is not under editorial workflow",
+        true
+      );
     });
   }
 
   isUnpublishedEntryModification(path, branch) {
     return this.readFile(path, null, {
       branch,
-      repoURL: this.originRepoURL,
+      repoURL: this.originRepoURL
     })
       .then(() => true)
       .catch(err => {
-        if (err.message && err.message === 'Not Found') {
+        if (err.message && err.message === "Not Found") {
           return false;
         }
         throw err;
@@ -371,7 +427,7 @@ export default class API {
     state,
     base = this.branch,
     repoURL = this.repoURL,
-    usernameOfFork,
+    usernameOfFork
   } = {}) => {
     // Get PRs with a `head` of `branchName`. Note that this is a
     // substring match, so we need to check that the `head.ref` of
@@ -380,8 +436,8 @@ export default class API {
       params: {
         head: usernameOfFork ? `${usernameOfFork}:${branchName}` : branchName,
         ...(state ? { state } : {}),
-        base,
-      },
+        base
+      }
     });
   };
 
@@ -390,13 +446,17 @@ export default class API {
     return prs.some(pr => pr.head.ref === branchName);
   };
 
-  getUpdatedOpenAuthoringMetadata = async (contentKey, { metadata: metadataArg } = {}) => {
-    const metadata = metadataArg || (await this.retrieveMetadata(contentKey)) || {};
+  getUpdatedOpenAuthoringMetadata = async (
+    contentKey,
+    { metadata: metadataArg } = {}
+  ) => {
+    const metadata =
+      metadataArg || (await this.retrieveMetadata(contentKey)) || {};
     const { pr: prMetadata, status } = metadata;
 
     // Set the status to draft if no corresponding PR is recorded
-    if (!prMetadata && status !== 'draft') {
-      const newMetadata = { ...metadata, status: 'draft' };
+    if (!prMetadata && status !== "draft") {
+      const newMetadata = { ...metadata, status: "draft" };
       this.storeMetadata(contentKey, newMetadata);
       return newMetadata;
     }
@@ -407,21 +467,21 @@ export default class API {
       const { number: prNumber } = prMetadata;
       const originPRInfo = await this.getPullRequest(prNumber);
       const { state: currentState, merged_at: mergedAt } = originPRInfo;
-      if (currentState === 'closed' && mergedAt) {
+      if (currentState === "closed" && mergedAt) {
         // The PR has been merged; delete the unpublished entry
-        const [, collectionName, slug] = contentKey.split('/');
+        const [, collectionName, slug] = contentKey.split("/");
         this.deleteUnpublishedEntry(collectionName, slug);
         return;
-      } else if (currentState === 'closed' && !mergedAt) {
-        if (status !== 'draft') {
-          const newMetadata = { ...metadata, status: 'draft' };
+      } else if (currentState === "closed" && !mergedAt) {
+        if (status !== "draft") {
+          const newMetadata = { ...metadata, status: "draft" };
           await this.storeMetadata(contentKey, newMetadata);
           return newMetadata;
         }
       } else {
-        if (status !== 'pending_review') {
+        if (status !== "pending_review") {
           // PR is open and has not been merged
-          const newMetadata = { ...metadata, status: 'pending_review' };
+          const newMetadata = { ...metadata, status: "pending_review" };
           await this.storeMetadata(contentKey, newMetadata);
           return newMetadata;
         }
@@ -433,11 +493,14 @@ export default class API {
 
   async listUnpublishedBranches() {
     console.log(
-      '%c Checking for Unpublished entries',
-      'line-height: 30px;text-align: center;font-weight: bold',
+      "%c Checking for Unpublished entries",
+      "line-height: 30px;text-align: center;font-weight: bold"
     );
     const onlyBranchesWithOpenPRs = filterPromisesWith(({ ref }) =>
-      this.branchHasPR({ branchName: this.branchNameFromRef(ref), state: 'open' }),
+      this.branchHasPR({
+        branchName: this.branchNameFromRef(ref),
+        state: "open"
+      })
     );
     const getUpdatedOpenAuthoringBranches = flow([
       map(async branch => {
@@ -445,24 +508,24 @@ export default class API {
         const metadata = await this.getUpdatedOpenAuthoringMetadata(contentKey);
         // filter out removed entries
         if (!metadata) {
-          return Promise.reject('Unpublished entry was removed');
+          return Promise.reject("Unpublished entry was removed");
         }
         return branch;
       }),
-      onlySuccessfulPromises,
+      onlySuccessfulPromises
     ]);
     try {
-      const branches = await this.request(`${this.repoURL}/git/refs/heads/cms`).catch(
-        replace404WithEmptyArray,
-      );
+      const branches = await this.request(
+        `${this.repoURL}/git/refs/heads/cms`
+      ).catch(replace404WithEmptyArray);
       const filterFunction = this.useOpenAuthoring
         ? getUpdatedOpenAuthoringBranches
         : onlyBranchesWithOpenPRs;
       return await filterFunction(branches);
     } catch (err) {
       console.log(
-        '%c No Unpublished entries',
-        'line-height: 30px;text-align: center;font-weight: bold',
+        "%c No Unpublished entries",
+        "line-height: 30px;text-align: center;font-weight: bold"
       );
       throw err;
     }
@@ -474,10 +537,12 @@ export default class API {
    */
   async getStatuses(sha) {
     try {
-      const resp = await this.request(`${this.originRepoURL}/commits/${sha}/status`);
+      const resp = await this.request(
+        `${this.originRepoURL}/commits/${sha}/status`
+      );
       return resp.statuses;
     } catch (err) {
-      if (err && err.message && err.message === 'Ref not found') {
+      if (err && err.message && err.message === "Ref not found") {
         return [];
       }
       throw err;
@@ -495,7 +560,7 @@ export default class API {
       if (file.uploaded) {
         return;
       }
-      parts = file.path.split('/').filter(part => part);
+      parts = file.path.split("/").filter(part => part);
       filename = parts.pop();
       subtree = fileTree;
       while ((part = parts.shift())) {
@@ -526,12 +591,22 @@ export default class API {
     return Promise.all(uploadPromises).then(() => {
       if (!options.useWorkflow) {
         return this.getBranch()
-          .then(branchData => this.updateTree(branchData.commit.sha, '/', fileTree))
+          .then(branchData =>
+            this.updateTree(branchData.commit.sha, "/", fileTree)
+          )
           .then(changeTree => this.commit(options.commitMessage, changeTree))
           .then(response => this.patchBranch(this.branch, response.sha));
       } else {
-        const mediaFilesList = mediaFiles.map(file => ({ path: file.path, sha: file.sha }));
-        return this.editorialWorkflowGit(fileTree, entry, mediaFilesList, options);
+        const mediaFilesList = mediaFiles.map(file => ({
+          path: file.path,
+          sha: file.sha
+        }));
+        return this.editorialWorkflowGit(
+          fileTree,
+          entry,
+          mediaFilesList,
+          options
+        );
       }
     });
   }
@@ -543,13 +618,13 @@ export default class API {
      * through the tree.
      */
 
-    const pathArray = path.split('/');
+    const pathArray = path.split("/");
     const filename = last(pathArray);
-    const directory = initial(pathArray).join('/');
+    const directory = initial(pathArray).join("/");
     const fileDataPath = encodeURIComponent(directory);
     const fileDataURL = `${this.repoURL}/git/trees/${branch}:${fileDataPath}`;
 
-    return this.request(fileDataURL, { cache: 'no-store' }).then(resp => {
+    return this.request(fileDataURL, { cache: "no-store" }).then(resp => {
       const { sha } = resp.tree.find(file => file.path === filename);
       return sha;
     });
@@ -557,17 +632,19 @@ export default class API {
 
   deleteFile(path, message, options = {}) {
     if (this.useOpenAuthoring) {
-      return Promise.reject('Cannot delete published entries as an Open Authoring user!');
+      return Promise.reject(
+        "Cannot delete published entries as an Open Authoring user!"
+      );
     }
 
     const branch = options.branch || this.branch;
 
     return this.getFileSha(path, branch).then(sha => {
-      const opts = { method: 'DELETE', params: { sha, message, branch } };
+      const opts = { method: "DELETE", params: { sha, message, branch } };
       if (this.commitAuthor) {
         opts.params.author = {
           ...this.commitAuthor,
-          date: new Date().toISOString(),
+          date: new Date().toISOString()
         };
       }
       const fileURL = `${this.repoURL}/contents/${path}`;
@@ -581,15 +658,25 @@ export default class API {
   }
 
   async editorialWorkflowGit(fileTree, entry, filesList, options) {
-    const contentKey = this.generateContentKey(options.collectionName, entry.slug);
+    const contentKey = this.generateContentKey(
+      options.collectionName,
+      entry.slug
+    );
     const branchName = this.generateBranchName(contentKey);
     const unpublished = options.unpublished || false;
     if (!unpublished) {
       // Open new editorial review workflow for this entry - Create new metadata and commit to new branch
       const userPromise = this.user();
       const branchData = await this.getBranch();
-      const changeTree = await this.updateTree(branchData.commit.sha, '/', fileTree);
-      const commitResponse = await this.commit(options.commitMessage, changeTree);
+      const changeTree = await this.updateTree(
+        branchData.commit.sha,
+        "/",
+        fileTree
+      );
+      const commitResponse = await this.commit(
+        options.commitMessage,
+        changeTree
+      );
 
       let pr;
       if (this.useOpenAuthoring) {
@@ -598,17 +685,17 @@ export default class API {
         pr = await this.createBranchAndPullRequest(
           branchName,
           commitResponse.sha,
-          options.commitMessage,
+          options.commitMessage
         );
       }
 
       const user = await userPromise;
       return this.storeMetadata(contentKey, {
-        type: 'PR',
+        type: "PR",
         pr: pr
           ? {
               number: pr.number,
-              head: pr.head && pr.head.sha,
+              head: pr.head && pr.head.sha
             }
           : undefined,
         user: user.name || user.login,
@@ -621,26 +708,33 @@ export default class API {
         objects: {
           entry: {
             path: entry.path,
-            sha: entry.sha,
+            sha: entry.sha
           },
-          files: filesList,
+          files: filesList
         },
-        timeStamp: new Date().toISOString(),
+        timeStamp: new Date().toISOString()
       });
     } else {
       // Entry is already on editorial review workflow - just update metadata and commit to existing branch
       const branchData = await this.getBranch(branchName);
-      const changeTree = await this.updateTree(branchData.commit.sha, '/', fileTree);
+      const changeTree = await this.updateTree(
+        branchData.commit.sha,
+        "/",
+        fileTree
+      );
       const commitPromise = this.commit(options.commitMessage, changeTree);
       const metadataPromise = this.retrieveMetadata(contentKey);
-      const [commit, metadata] = await Promise.all([commitPromise, metadataPromise]);
+      const [commit, metadata] = await Promise.all([
+        commitPromise,
+        metadataPromise
+      ]);
       const { title, description } = options.parsedData || {};
-      const metadataFiles = get(metadata.objects, 'files', []);
+      const metadataFiles = get(metadata.objects, "files", []);
       const files = [...metadataFiles, ...filesList];
       const pr = metadata.pr ? { ...metadata.pr, head: commit.sha } : undefined;
       const objects = {
         entry: { path: entry.path, sha: entry.sha },
-        files: uniq(files),
+        files: uniq(files)
       };
       const updatedMetadata = { ...metadata, pr, title, description, objects };
 
@@ -650,7 +744,13 @@ export default class API {
       }
 
       if (pr) {
-        return this.rebasePullRequest(pr.number, branchName, contentKey, metadata, commit);
+        return this.rebasePullRequest(
+          pr.number,
+          branchName,
+          contentKey,
+          metadata,
+          commit
+        );
       } else if (this.useOpenAuthoring) {
         // if a PR hasn't been created yet for the forked repo, just patch the branch
         await this.patchBranch(branchName, commit.sha, { force: true });
@@ -680,7 +780,7 @@ export default class API {
        */
       const [baseBranch, commits] = await Promise.all([
         this.getBranch(),
-        this.getPullRequestCommits(prNumber, head),
+        this.getPullRequestCommits(prNumber, head)
       ]);
 
       /**
@@ -691,7 +791,11 @@ export default class API {
        * neither the head we expect nor its parent.
        */
       const finalCommits = this.assertHead(commits, head);
-      const rebasedHead = await this.rebaseSingleBlobCommits(baseBranch.commit, finalCommits, path);
+      const rebasedHead = await this.rebaseSingleBlobCommits(
+        baseBranch.commit,
+        finalCommits,
+        path
+      );
 
       /**
        * Update metadata, then force update the pull request branch head.
@@ -769,12 +873,16 @@ export default class API {
          * blob. Use the full path to indicate nesting, GitHub will take care of
          * subtree creation.
          */
-        .then(blob => this.createTree(baseCommit.tree.sha, [{ ...blob, path: pathToBlob }]))
+        .then(blob =>
+          this.createTree(baseCommit.tree.sha, [{ ...blob, path: pathToBlob }])
+        )
 
         /**
          * Create a new commit with the updated tree and original commit metadata.
          */
-        .then(tree => this.createCommit(message, tree.sha, parent, author, committer))
+        .then(tree =>
+          this.createCommit(message, tree.sha, parent, author, committer)
+        )
     );
   }
 
@@ -807,7 +915,7 @@ export default class API {
       return commits;
     }
 
-    throw Error('Editorial workflow branch changed unexpectedly.');
+    throw Error("Editorial workflow branch changed unexpectedly.");
   }
 
   async updateUnpublishedEntryStatus(collectionName, slug, status) {
@@ -817,12 +925,14 @@ export default class API {
     if (!this.useOpenAuthoring) {
       return this.storeMetadata(contentKey, {
         ...metadata,
-        status,
+        status
       });
     }
 
-    if (status === 'pending_publish') {
-      throw new Error('Open Authoring entries may not be set to the status "pending_publish".');
+    if (status === "pending_publish") {
+      throw new Error(
+        'Open Authoring entries may not be set to the status "pending_publish".'
+      );
     }
 
     const { pr: prMetadata } = metadata;
@@ -830,31 +940,32 @@ export default class API {
       const { number: prNumber } = prMetadata;
       const originPRInfo = await this.getPullRequest(prNumber);
       const { state } = originPRInfo;
-      if (state === 'open' && status === 'draft') {
+      if (state === "open" && status === "draft") {
         await this.closePR(prMetadata);
         return this.storeMetadata(contentKey, {
           ...metadata,
-          status,
+          status
         });
       }
 
-      if (state === 'closed' && status === 'pending_review') {
+      if (state === "closed" && status === "pending_review") {
         await this.openPR(prMetadata);
         return this.storeMetadata(contentKey, {
           ...metadata,
-          status,
+          status
         });
       }
     }
 
-    if (!prMetadata && status === 'pending_review') {
+    if (!prMetadata && status === "pending_review") {
       const branchName = this.generateBranchName(contentKey);
-      const commitMessage = metadata.commitMessage || API.DEFAULT_COMMIT_MESSAGE;
+      const commitMessage =
+        metadata.commitMessage || API.DEFAULT_COMMIT_MESSAGE;
       const { number, head } = await this.createPR(commitMessage, branchName);
       return this.storeMetadata(contentKey, {
         ...metadata,
         pr: { number, head },
-        status,
+        status
       });
     }
   }
@@ -864,13 +975,17 @@ export default class API {
     const branchName = this.generateBranchName(contentKey);
     return (
       this.retrieveMetadata(contentKey)
-        .then(metadata => (metadata && metadata.pr ? this.closePR(metadata.pr) : Promise.resolve()))
+        .then(metadata =>
+          metadata && metadata.pr
+            ? this.closePR(metadata.pr)
+            : Promise.resolve()
+        )
         .then(() => this.deleteBranch(branchName))
         // If the PR doesn't exist, then this has already been deleted -
         // deletion should be idempotent, so we can consider this a
         // success.
         .catch(err => {
-          if (err.message === 'Reference does not exist') {
+          if (err.message === "Reference does not exist") {
             return Promise.resolve();
           }
           console.error(err);
@@ -889,31 +1004,39 @@ export default class API {
 
   createRef(type, name, sha) {
     return this.request(`${this.repoURL}/git/refs`, {
-      method: 'POST',
-      body: JSON.stringify({ ref: `refs/${type}/${name}`, sha }),
+      method: "POST",
+      body: JSON.stringify({ ref: `refs/${type}/${name}`, sha })
     });
   }
 
   patchRef(type, name, sha, opts = {}) {
     const force = opts.force || false;
-    return this.request(`${this.repoURL}/git/refs/${type}/${encodeURIComponent(name)}`, {
-      method: 'PATCH',
-      body: JSON.stringify({ sha, force }),
-    });
+    return this.request(
+      `${this.repoURL}/git/refs/${type}/${encodeURIComponent(name)}`,
+      {
+        method: "PATCH",
+        body: JSON.stringify({ sha, force })
+      }
+    );
   }
 
   deleteRef(type, name) {
-    return this.request(`${this.repoURL}/git/refs/${type}/${encodeURIComponent(name)}`, {
-      method: 'DELETE',
-    });
+    return this.request(
+      `${this.repoURL}/git/refs/${type}/${encodeURIComponent(name)}`,
+      {
+        method: "DELETE"
+      }
+    );
   }
 
   getBranch(branch = this.branch) {
-    return this.request(`${this.repoURL}/branches/${encodeURIComponent(branch)}`);
+    return this.request(
+      `${this.repoURL}/branches/${encodeURIComponent(branch)}`
+    );
   }
 
   createBranch(branchName, sha) {
-    return this.createRef('heads', branchName, sha);
+    return this.createRef("heads", branchName, sha);
   }
 
   assertCmsBranch(branchName) {
@@ -923,60 +1046,73 @@ export default class API {
   patchBranch(branchName, sha, opts = {}) {
     const force = opts.force || false;
     if (force && !this.assertCmsBranch(branchName)) {
-      throw Error(`Only CMS branches can be force updated, cannot force update ${branchName}`);
+      throw Error(
+        `Only CMS branches can be force updated, cannot force update ${branchName}`
+      );
     }
-    return this.patchRef('heads', branchName, sha, { force });
+    return this.patchRef("heads", branchName, sha, { force });
   }
 
   deleteBranch(branchName) {
-    return this.deleteRef('heads', branchName);
+    return this.deleteRef("heads", branchName);
   }
 
   async createPR(title, head) {
-    const headReference = this.useOpenAuthoring ? `${(await this.user()).login}:${head}` : head;
+    const headReference = this.useOpenAuthoring
+      ? `${(await this.user()).login}:${head}`
+      : head;
     return this.request(`${this.originRepoURL}/pulls`, {
-      method: 'POST',
+      method: "POST",
       body: JSON.stringify({
         title,
         body: API.DEFAULT_PR_BODY,
         head: headReference,
-        base: this.branch,
-      }),
+        base: this.branch
+      })
     });
   }
 
   async openPR(pullRequest) {
     const { number } = pullRequest;
-    console.log('%c Re-opening PR', 'line-height: 30px;text-align: center;font-weight: bold');
+    console.log(
+      "%c Re-opening PR",
+      "line-height: 30px;text-align: center;font-weight: bold"
+    );
     return this.request(`${this.originRepoURL}/pulls/${number}`, {
-      method: 'PATCH',
+      method: "PATCH",
       body: JSON.stringify({
-        state: 'open',
-      }),
+        state: "open"
+      })
     });
   }
 
   closePR(pullRequest) {
     const { number } = pullRequest;
-    console.log('%c Deleting PR', 'line-height: 30px;text-align: center;font-weight: bold');
+    console.log(
+      "%c Deleting PR",
+      "line-height: 30px;text-align: center;font-weight: bold"
+    );
     return this.request(`${this.originRepoURL}/pulls/${number}`, {
-      method: 'PATCH',
+      method: "PATCH",
       body: JSON.stringify({
-        state: 'closed',
-      }),
+        state: "closed"
+      })
     });
   }
 
   mergePR(pullrequest, objects) {
     const { head: headSha, number } = pullrequest;
-    console.log('%c Merging PR', 'line-height: 30px;text-align: center;font-weight: bold');
+    console.log(
+      "%c Merging PR",
+      "line-height: 30px;text-align: center;font-weight: bold"
+    );
     return this.request(`${this.originRepoURL}/pulls/${number}/merge`, {
-      method: 'PUT',
+      method: "PUT",
       body: JSON.stringify({
-        commit_message: 'Automatically generated. Merged on Netlify CMS.',
+        commit_message: "Automatically generated. Merged on Netlify CMS.",
         sha: headSha,
-        merge_method: this.merge_method,
-      }),
+        merge_method: this.merge_method
+      })
     }).catch(error => {
       if (error instanceof APIError && error.status === 405) {
         return this.forceMergePR(pullrequest, objects);
@@ -989,16 +1125,17 @@ export default class API {
   forceMergePR(pullrequest, objects) {
     const files = objects.files.concat(objects.entry);
     const fileTree = this.composeFileTree(files);
-    let commitMessage = 'Automatically generated. Merged on Netlify CMS\n\nForce merge of:';
+    let commitMessage =
+      "Automatically generated. Merged on Netlify CMS\n\nForce merge of:";
     files.forEach(file => {
       commitMessage += `\n* "${file.path}"`;
     });
     console.log(
-      '%c Automatic merge not possible - Forcing merge.',
-      'line-height: 30px;text-align: center;font-weight: bold',
+      "%c Automatic merge not possible - Forcing merge.",
+      "line-height: 30px;text-align: center;font-weight: bold"
     );
     return this.getBranch()
-      .then(branchData => this.updateTree(branchData.commit.sha, '/', fileTree))
+      .then(branchData => this.updateTree(branchData.commit.sha, "/", fileTree))
       .then(changeTree => this.commit(commitMessage, changeTree))
       .then(response => this.patchBranch(this.branch, response.sha));
   }
@@ -1015,7 +1152,7 @@ export default class API {
    * nested within one or more directories.
    */
   getBlobInTree(treeSha, pathToBlob) {
-    const pathSegments = pathToBlob.split('/').filter(val => val);
+    const pathSegments = pathToBlob.split("/").filter(val => val);
     const directories = pathSegments.slice(0, -1);
     const filename = pathSegments.slice(-1)[0];
     const baseTree = this.getTree(treeSha);
@@ -1025,7 +1162,9 @@ export default class API {
         return this.getTree(subTreeSha);
       });
     }, baseTree);
-    return subTreePromise.then(subTree => find(subTree.tree, { path: filename }));
+    return subTreePromise.then(subTree =>
+      find(subTree.tree, { path: filename })
+    );
   }
 
   toBase64(str) {
@@ -1033,20 +1172,20 @@ export default class API {
   }
 
   uploadBlob(item) {
-    const content = result(item, 'toBase64', partial(this.toBase64, item.raw));
+    const content = result(item, "toBase64", partial(this.toBase64, item.raw));
 
     return content.then(contentBase64 =>
       this.request(`${this.repoURL}/git/blobs`, {
-        method: 'POST',
+        method: "POST",
         body: JSON.stringify({
           content: contentBase64,
-          encoding: 'base64',
-        }),
+          encoding: "base64"
+        })
       }).then(response => {
         item.sha = response.sha;
         item.uploaded = true;
         return item;
-      }),
+      })
     );
   }
 
@@ -1064,7 +1203,12 @@ export default class API {
           // eslint-disable-line no-cond-assign
           added[obj.path] = true;
           if (fileOrDir.file) {
-            updates.push({ path: obj.path, mode: obj.mode, type: obj.type, sha: fileOrDir.sha });
+            updates.push({
+              path: obj.path,
+              mode: obj.mode,
+              type: obj.type,
+              sha: fileOrDir.sha
+            });
           } else {
             updates.push(this.updateTree(obj.sha, obj.path, fileOrDir));
           }
@@ -1077,26 +1221,31 @@ export default class API {
         }
         updates.push(
           fileOrDir.file
-            ? { path: filename, mode: '100644', type: 'blob', sha: fileOrDir.sha }
-            : this.updateTree(null, filename, fileOrDir),
+            ? {
+                path: filename,
+                mode: "100644",
+                type: "blob",
+                sha: fileOrDir.sha
+              }
+            : this.updateTree(null, filename, fileOrDir)
         );
       }
       return Promise.all(updates)
         .then(tree => this.createTree(sha, tree))
         .then(response => ({
           path,
-          mode: '040000',
-          type: 'tree',
+          mode: "040000",
+          type: "tree",
           sha: response.sha,
-          parentSha: sha,
+          parentSha: sha
         }));
     });
   }
 
   createTree(baseSha, tree) {
     return this.request(`${this.repoURL}/git/trees`, {
-      method: 'POST',
-      body: JSON.stringify({ base_tree: baseSha, tree }),
+      method: "POST",
+      body: JSON.stringify({ base_tree: baseSha, tree })
     });
   }
 
@@ -1120,8 +1269,14 @@ export default class API {
 
   createCommit(message, treeSha, parents, author, committer) {
     return this.request(`${this.repoURL}/git/commits`, {
-      method: 'POST',
-      body: JSON.stringify({ message, tree: treeSha, parents, author, committer }),
+      method: "POST",
+      body: JSON.stringify({
+        message,
+        tree: treeSha,
+        parents,
+        author,
+        committer
+      })
     });
   }
 }
